/* Copyright Michael Rauter
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 the "License";
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

 #version 460

 #pragma shader_stage(compute)

//#extension GL_ARB_shading_language_include : require
//#extension GL_GOOGLE_include_directive : require

layout (local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

//layout (binding = 0, r8) uniform image3D volume; // r8 = float unorm
#if defined(VOLUME_DATATYPE_INT16)
    layout (binding = 0, r16i) uniform iimage3D volume;
#elif defined(VOLUME_DATATYPE_UINT16)
    layout (binding = 0, r16ui) uniform uimage3D volume;
#elif defined(VOLUME_DATATYPE_UINT8)
    layout (binding = 0, r8ui) uniform uimage3D volume;
#endif

#if defined(VOLUME_DATATYPE_OUPUT_UNORM16)
    layout (binding = 1, r16) uniform image3D output_volume;
#elif defined(VOLUME_DATATYPE_OUPUT_UNORM8)
    layout (binding = 1, r8) uniform image3D output_volume;
#endif

layout(std140, binding = 0) uniform UBO {
    float minIntensityValue;
    float maxIntensityValue;
};

float getVolumeIntensityValue(ivec3 samplingPos)
{
    float voxelValue = imageLoad(volume, samplingPos).x;
#if defined(VOLUME_DATATYPE_INT16) || defined(VOLUME_DATATYPE_UINT16) || defined(VOLUME_DATATYPE_UINT8)
    float intensityRangeWidth = maxIntensityValue - minIntensityValue + 1.0f;
    float reciprocalIntensityRangeWidth = 1.0f / intensityRangeWidth;
    voxelValue = (voxelValue - minIntensityValue) * reciprocalIntensityRangeWidth;
#endif
    return voxelValue;
}

void main() {
  const ivec3 dim = imageSize(volume);
  if(any(greaterThanEqual(gl_GlobalInvocationID, dim))) return;
  float intensityValueAsSNORM = getVolumeIntensityValue(ivec3(gl_GlobalInvocationID));
  vec4 converted_value = vec4(intensityValueAsSNORM, 0.0f, 0.0f, 0.0f);
  imageStore(output_volume, ivec3(gl_GlobalInvocationID), converted_value);
}
